#!/usr/bin/env python3
import os, sys, time, subprocess
from datetime import datetime
from dotenv import load_dotenv

# Ensure imports resolve (treat src as a package)
ROOT = os.getcwd()
PKG_PATH = os.path.join(ROOT, 'intelligence_layer')
if PKG_PATH not in sys.path:
    sys.path.append(PKG_PATH)

load_dotenv()

from src.database import (
    get_unprocessed_signals,
    mark_signal_processed,
)
from src.signal_processor import process_signal_complete

INBOUND_VALUES = {'inbound', 'received'}
BATCH_SIZE = int(os.getenv('BATCH_SIZE', '25'))
RUN_SESSIONIZER = os.getenv('RUN_SESSIONIZER', 'true').lower() == 'true'
SLEEP_BETWEEN = float(os.getenv('RUNNER_SLEEP_BETWEEN', '0.3'))


def run_whatsapp_sessionizer():
    if not RUN_SESSIONIZER:
        return
    print("Sessionizing WhatsApp (standard step)...")
    cmd = [
        sys.executable,
        os.path.join(ROOT, 'intelligence_layer', 'sessionize_whatsapp.py')
    ]
    try:
        # Ensure PYTHONPATH so sessionizer can import src.*
        env = os.environ.copy()
        env['PYTHONPATH'] = 'intelligence_layer'
        subprocess.run(cmd, check=True, env=env)
        print("WhatsApp sessionization completed.")
    except Exception as e:
        print(f"Sessionizer error (continuing): {e}")


def inbound_only_filter(rows):
    filtered = []
    for r in rows:
        src = (r.get('source_platform') or r.get('signal_type') or '').lower()
        if src == 'whatsapp':
            direction = (r.get('message_direction') or r.get('direction') or '').lower()
            if direction in INBOUND_VALUES:
                filtered.append(r)
        else:
            # reviews, surveys, etc. are customer-generated by default
            filtered.append(r)
    return filtered


def pretty_signal(row):
    sid = row.get('signal_id')
    typ = row.get('signal_type', 'unknown')
    plat = row.get('source_platform', 'unknown')
    text = (row.get('signal_text') or row.get('raw_content') or '')[:80]
    return f"{sid} [{plat}/{typ}] {text}..."


def run_batch(limit=BATCH_SIZE):
    print(f"Fetching up to {limit} unprocessed signals...")
    signals = get_unprocessed_signals(limit=limit) or []
    signals = inbound_only_filter(signals)
    if not signals:
        print("Nothing to process.")
        return {"processed": 0, "errors": 0, "cost": 0.0}

    print(f"Found {len(signals)} inbound signals to process")

    processed = 0
    errors = 0
    total_cost = 0.0

    for i, row in enumerate(signals, start=1):
        print(f"\nProcessing {i}/{len(signals)} {pretty_signal(row)}")
        sid = row.get('signal_id')
        try:
            result = process_signal_complete(sid)
            if result.get('error'):
                print(f"   Error: {result['error']}")
                mark_signal_processed(sid, 'error', result['error'])
                errors += 1
            else:
                cost = float(result.get('total_api_cost', 0.0) or 0.0)
                total_cost += cost
                print(f"   Done. Dominant: {result.get('col1_actor_segment',{}).get('dominant_driver','?')} | Cost: ${cost:.4f}")
                mark_signal_processed(sid, 'processed')
                processed += 1
        except Exception as e:
            print(f"   Exception: {e}")
            mark_signal_processed(sid, 'error', str(e))
            errors += 1
        time.sleep(SLEEP_BETWEEN)

    print("\nBatch summary")
    print(f"   Processed: {processed}")
    print(f"   Errors: {errors}")
    print(f"   Cost: ${total_cost:.4f}")
    return {"processed": processed, "errors": errors, "cost": total_cost}


def main():
    print("Unified Processor: sessionize -> analyze -> update profiles")
    print(f"   Started: {datetime.utcnow().isoformat()}Z")
    run_whatsapp_sessionizer()
    run_batch(BATCH_SIZE)
    print(f"   Finished: {datetime.utcnow().isoformat()}Z")


if __name__ == "__main__":
    main()


